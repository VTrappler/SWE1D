#!/usr/bin/env python
#-*- coding: utf-8 -*-

import wrapper_HR as swe
import numpy as np
import scipy

import matplotlib.pyplot as plt

# Ap_Pm -> A = 5.1; P = 49.8
# Ap_Pp -> A = 5.2; P = 50.1
# Am_Pp -> A = 4.9; P = 50.2
# Am_Pm -> A = 4.8; P = 49.9

#-- Paramètres de référence ------------------------------------------------------

print 'Hauteur eau moyenne = ', swe.mean_h
print 'Amplitude = ', swe.amplitude
print 'Periode = ', swe.period
print 'Phase = ', swe.phase
bcLref = lambda h, hu, t: swe.BCrand(h, hu, t, 'L',
                                 mean_h, amplitude, period, phase)
# [xr,href,uref,t] = swe.swe_KAP(swe.Kref, swe.amplitude, swe.period)

# swe.J_KAP_pw_obs(swe.Kref, A = swe.amplitude, P = swe.period, idx_to_observe = np.arange(swe.href.shape[0]))
# doit être égal à 0, [0.,...,0.]

idx_to_observe = np.array([50,100,150,200])-1

def J_KAP(K = swe.Kref,  A = swe.amplitude, P = swe.period, idx_to_observe = idx_to_observe):
    """
    Computes RSS and its gradient wrt to K, with amplitude, period and observation index

    Parameters
    ----------
    K : array_like
        Coefficients of the vector of bottom friction, if K.size < number of volumes, interpolation is used
    A : float, optional
        Value of the amplitude used to compute the RSS, by default swe.amplitude = 5.0
    P : float, optional
        Value of the period used to compute the RSS, by default swe.amplitude = 15.0
    idx_to_observe : array_like
        Indices of the spatial domain where h is observed, by default idx_to_observe

    Returns
    -------
    tuple
        first element of the tuple is the RSS, second is the gradient wrt to K. Second element is the same length as K
    
    """
    return swe.J_KAP_pw_obs(K, A, P, idx_to_observe)

optimization = scipy.optimize.minimize(fun = J_KAP, x0 = 0.1*np.ones_like(swe.xr), # Optimization in dim K = 200
                                       args = (swe.amplitude, swe.period), jac = True, # U = uref, N_obs = 4
                        bounds = swe.N*[(0.0,None)])

dimK = 4 
optimization_4pts_4obs_nfeval = scipy.optimize.minimize(fun = J_KAP, x0 = 0.1*np.ones(dimK), # Optimization in dim K reduit = 8
                                    args = (swe.amplitude, swe.period), jac = True, # U = uref, N_obs = 8
                                                        bounds = dimK*[(0.0,None)], options = {'maxiter':15})


plt.plot(swe.xr[1:-1],swe.Kref[1:-1], label = 'Kref')
plt.plot(swe.xr[1:-1],map(swe.interp(optimization_8pts_4obs.x), swe.xr[1:-1]), label = 'optimization result')
plt.plot(swe.xr[1:-1],map(swe.interp(optimization_8pts_4obs_nfeval.x), swe.xr[1:-1]), label = 'optimization result , nit = 15')
plt.plot(swe.xr[1:-1],map(swe.interp(optimization_4pts_4obs_nfeval.x), swe.xr[1:-1]), label = 'optimization result , nit = 15')

plt.vlines(idx_to_observe/2,0,.4, label = 'obs points', linestyles = 'dotted')
plt.grid()
plt.legend()
plt.title('Optimization using adjoint, $\dim \mathcal{K}$=200 and no uncertainties')
plt.show()
